import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders } from '../_shared/cors.ts';

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const bookingData = await req.json();

    const {
      tour_id,
      date_slot_id,
      hiker_id,
      participants,
      participants_details,
      total_price,
      subtotal,
      discount_code,
      discount_amount,
      service_fee_amount,
      currency,
      special_requests,
      stripe_payment_intent_id,
      primary_contact_id,
    } = bookingData;

    if (!tour_id || !date_slot_id || !hiker_id || !participants || !total_price) {
      return new Response(
        JSON.stringify({ error: 'Missing required booking information' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Create Supabase client
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Get tour info and check auto_confirm setting
    const { data: tour, error: tourError } = await supabase
      .from('tours')
      .select('title, guide_id, auto_confirm, region')
      .eq('id', tour_id)
      .single();

    if (tourError || !tour) {
      return new Response(
        JSON.stringify({ error: 'Tour not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Get date slot info
    const { data: dateSlot, error: dateSlotError } = await supabase
      .from('tour_date_slots')
      .select('slot_date, spots_remaining, spots_booked, spots_total')
      .eq('id', date_slot_id)
      .single();

    if (dateSlotError || !dateSlot) {
      return new Response(
        JSON.stringify({ error: 'Date slot not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Check if enough spots are available
    if (dateSlot.spots_remaining < participants) {
      return new Response(
        JSON.stringify({ error: 'Not enough spots available' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Determine booking status based on auto_confirm setting
    const bookingStatus = tour.auto_confirm ? 'confirmed' : 'pending_confirmation';

    // Create booking record (booking_reference will be auto-generated by trigger)
    const { data: booking, error: bookingError } = await supabase
      .from('bookings')
      .insert({
        tour_id,
        date_slot_id,
        hiker_id,
        booking_date: dateSlot.slot_date,
        participants,
        participants_details,
        total_price,
        subtotal,
        discount_code,
        discount_amount: discount_amount || 0,
        service_fee_amount: service_fee_amount || 0,
        currency,
        status: bookingStatus,
        payment_status: 'succeeded',
        special_requests,
        stripe_payment_intent_id,
        primary_contact_id,
      })
      .select()
      .single();

    if (bookingError) {
      console.error('Error creating booking:', bookingError);
      return new Response(
        JSON.stringify({ error: 'Failed to create booking' }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Update tour_date_slots to reflect booked spots
    const newSpotsBooked = dateSlot.spots_booked + participants;
    const newSpotsRemaining = dateSlot.spots_total - newSpotsBooked;
    const { error: updateSlotsError } = await supabase
      .from('tour_date_slots')
      .update({
        spots_booked: newSpotsBooked,
        spots_remaining: newSpotsRemaining,
      })
      .eq('id', date_slot_id);

    if (updateSlotsError) {
      console.error('Error updating slots:', updateSlotsError);
    }

    // Increment discount code usage if applicable
    if (discount_code) {
      await supabase.rpc('increment', {
        table_name: 'discount_codes',
        column_name: 'times_used',
        row_id: discount_code
      });
    }

    // Create conversation between hiker and guide
    const { data: conversation, error: conversationError } = await supabase
      .from('conversations')
      .insert({
        hiker_id: hiker_id,
        guide_id: tour.guide_id,
        tour_id: tour_id,
        last_message_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (conversationError) {
      console.error('Error creating conversation:', conversationError);
    }

    // Send confirmation email to hiker
    const { data: hikerProfile } = await supabase
      .from('profiles')
      .select('email, name')
      .eq('id', hiker_id)
      .single();

    if (hikerProfile) {
      await supabase.functions.invoke('send-email', {
        body: {
          to: hikerProfile.email,
          subject: `Booking Confirmation - ${tour.title}`,
          template: 'booking-confirmation',
          data: {
            hikerName: hikerProfile.name,
            tourTitle: tour.title,
            bookingReference: booking.booking_reference,
            bookingDate: dateSlot.slot_date,
            participants,
            totalPrice: total_price,
            currency,
            status: bookingStatus,
            region: tour.region,
          }
        }
      });
    }

    // Send booking notification to guide
    const { data: guideProfile } = await supabase
      .from('profiles')
      .select('email, name')
      .eq('id', tour.guide_id)
      .single();

    if (guideProfile) {
      await supabase.functions.invoke('send-email', {
        body: {
          to: guideProfile.email,
          subject: `New Booking - ${tour.title}`,
          template: 'guide-booking-notification',
          data: {
            guideName: guideProfile.name,
            tourTitle: tour.title,
            bookingReference: booking.booking_reference,
            hikerName: hikerProfile?.name,
            bookingDate: dateSlot.slot_date,
            participants,
            totalPrice: total_price,
            currency,
            specialRequests: special_requests,
          }
        }
      });
    }

    return new Response(
      JSON.stringify({
        booking,
        conversation,
        message: 'Booking created successfully'
      }),
      { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('Error in create-booking:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
